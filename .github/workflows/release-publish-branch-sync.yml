name: "Post-release automation"

env:
  GH_TOKEN:          ${{ secrets.GITHUB_TOKEN }}
  SLACK_WEBHOOK_URL: ${{ secrets.SLACK_RELEASE_WORKFLOW_URL }}

permissions:
  contents: write
  pull-requests: write

on:
  release:
    types: [released]

jobs:
  post_release:
    runs-on: ubuntu-latest

    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      with: { fetch-depth: 0 }

    - name: Generate release notes if missing
      shell: bash
      run: |
        tag=${{ github.event.release.tag_name }}

        # Fetch current release notes
        body=$(gh api repos/${{ github.repository }}/releases/tags/"$tag" --jq .body)
        body=${body:-}

        # Check if release notes already contain changelog
        if [[ -n "$body" && "$body" != "null" ]] && \
          grep -qiE "What's[[:space:]]+Changed|Full[[:space:]]+Changelog" <<<"$body"; then
          echo "Release notes already contain changelog, skipping generation."
          exit 0
        fi

        # Generating release notes
        gen=$(gh api --method POST \
                repos/${{ github.repository }}/releases/generate-notes \
                -f tag_name="$tag" --jq .body)

        tmp=$(mktemp)

        if [[ -z "$body" || "$body" == "null" ]]; then
          # No previous notes → just write the generated changelog
          printf '%s\n' "$gen" >"$tmp"
        else
          printf '%s\n\n---\n\n%s\n' "$body" "$gen" >"$tmp"
        fi

        gh release edit "$tag" --notes-file "$tmp"

    - name: Create PR (master → stage)
      id: pr_master_stage
      env:
        GH_TOKEN: ${{ secrets.PR_CREATOR_TOKEN }}
      shell: bash
      run: |
        tag=${{ github.event.release.tag_name }}
        url=$(gh pr list --state open --head master --base stage --json url --jq '.[0].url' || true)

        if [[ -z $url ]]; then
          set +e
          output=$(gh pr create --head master --base stage \
                     --title "Sync master to stage after $tag" \
                     --body  "Automated sync PR after $tag." 2>&1)
          status=$?
          set -e
          if [[ $status -eq 0 ]]; then
            url=$(echo "$output" | tail -n1)
          else
            echo "::notice::No commits between master and stage - skipping PR"
            url="N/A"
          fi
        fi

        if [[ $url == https:* ]]; then
          gh pr edit "$url" --add-label automated-pr || true
          num=${url##*/}
        else
          num="N/A"
        fi

        echo "url=$url"   >>"$GITHUB_OUTPUT"
        echo "number=$num" >>"$GITHUB_OUTPUT"

    - name: Create PR (stage → develop)
      id: pr_stage_develop
      env:
        GH_TOKEN: ${{ secrets.PR_CREATOR_TOKEN }}
      shell: bash
      run: |
        tag=${{ github.event.release.tag_name }}
        master_stage_url=${{ steps.pr_master_stage.outputs.url }}
        url=$(gh pr list --state open --head stage --base develop --json url --jq '.[0].url' || true)

        if [[ -z $url ]]; then
          set +e
          output=$(gh pr create --head stage --base develop \
                     --title "Sync stage to develop after $tag" \
                     --body  "Please merge the master → stage PR first:\n${master_stage_url}" 2>&1)
          status=$?
          set -e
          if [[ $status -eq 0 ]]; then
            url=$(echo "$output" | tail -n1)
          else
            echo "::notice::No commits between stage and develop - skipping PR"
            url="N/A"
          fi
        fi

        if [[ $url == https:* ]]; then
          gh pr edit "$url" --add-label automated-pr || true
        fi

        echo "url=$url" >>"$GITHUB_OUTPUT"

    - name: Resolve actor email
      id: actor_email
      shell: bash
      run: |
        email=$(gh api users/${{ github.actor }} --jq .email 2>/dev/null || echo "")
        echo "email=$email" >>"$GITHUB_OUTPUT"

    - name: Send release notification
      shell: bash
      run: |
        pr1="${{ steps.pr_master_stage.outputs.url }}"
        pr2="${{ steps.pr_stage_develop.outputs.url }}"

        payload=$(jq -n \
          --arg event "post_release" \
          --arg title "Release ${{ github.event.release.tag_name }} published" \
          --arg body  "Release notes: ${{ github.event.release.html_url }}" \
          --arg actor "${{ steps.actor_email.outputs.email }}" \
          --arg postReleaseStagePR   "$pr1" \
          --arg postReleaseDevelopPR "$pr2" \
          '{event:$event,
            title:$title,
            body:$body,
            actor:$actor,
            postReleaseStagePR:$postReleaseStagePR,
            postReleaseDevelopPR:$postReleaseDevelopPR}')

        curl -s -X POST -H 'Content-Type: application/json' \
             --data "$payload" "$SLACK_WEBHOOK_URL"

    - name: DM contributors with their PRs
      shell: bash
      env:
        REPO: ${{ github.repository }}
      run: |
        set -euo pipefail

        current_tag="${{ github.event.release.tag_name }}"
        release_url="https://github.com/${REPO}/releases/tag/${current_tag}"

        prev_tag=$(gh release list --repo "$REPO" --limit 3 \
                    --json tagName,publishedAt \
                    --jq 'map(select(.tagName != "'"$current_tag"'")) |
                          sort_by(.publishedAt) | last.tagName')

        if [[ -z "$prev_tag" || "$prev_tag" == "null" ]]; then
          echo "No previous release found; skipping contributor DMs."
          exit 0
        fi

        # Commits between prev..current
        shas=$(gh api repos/$REPO/compare/${prev_tag}...${current_tag} \
              --jq '.commits[].sha')

        echo "Found commits: $shas"

        tmp=$(mktemp)
        : > "$tmp"
        while read -r sha; do
          [[ -z "$sha" ]] && continue
          gh api repos/$REPO/commits/$sha/pulls \
            --jq '.[] | select(.base.ref=="develop" and .merged_at!=null)
                  | {number, title, url:.html_url,
                      headRef:(.head|.ref), author:(.user|.login)}' \
            >> "$tmp" || true
        done <<< "$shas"

        [[ ! -s "$tmp" ]] && { echo "No develop PRs for this release window."; exit 0; }

        grouped=$(jq -s 'group_by(.author)
                        | map({author: .[0].author, prs: .})' "$tmp")

        resolve_email() {
          local login="$1"
          local email
          email=$(gh api users/"$login" --jq .email 2>/dev/null || echo "")
          [[ -z "$email" || "$email" == "null" ]] && email=""
          printf '%s' "$email"
        }

        sent=0
        echo "$grouped" | jq -c '.[]' | while read -r row; do
          login=$(jq -r '.author' <<<"$row")
          email=$(resolve_email "$login")

          #  Skip if no email
          [[ -z "$email" ]] && { echo "No email for $login — skipping"; continue; }

          pr_text=$(jq -r '
            .prs | map("- [#" + (.number|tostring) + "](" + .url + ") — " +
                      .title + "  (branch: `" + .headRef + "`)")
            | join("\n")
          ' <<<"$row")

          payload=$(
            jq -n \
              --arg event       "post_release_contributor_dm" \
              --arg actor       "$email" \
              --arg title       "Your changes are in release ${current_tag}" \
              --arg body        "Thanks for contributing!  \n${pr_text}\n\nPlease delete feature branches you no longer need." \
              --arg releaseUrl  "$release_url" \
              '{event:$event,
                actor:$actor,
                title:$title,
                body:$body,
                releaseUrl:$releaseUrl}'
          )

          # Log notification details
          echo "Sending Slack notification to: $login <$email>"
          echo "Event: post_release_contributor_dm"
          echo "Full payload:"
          echo "$payload" | jq '.'

          curl -s -X POST -H 'Content-Type: application/json' \
              --data "$payload" "$SLACK_WEBHOOK_URL" >/dev/null || true
          sent=$((sent+1))
          echo "DM sent to $login <$email>"
        done

        echo "Total DMs sent: $sent"

